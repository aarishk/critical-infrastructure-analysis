# CMPT 318 (Fall 2018)
# Group Assignment 2
#
# Authors:
#   Aarish Kapila
#   Che Jung (Kent) Lee
#   Karan Sharma
#   Razvan Andrei Cretu
#   Yernur Nursultanov

library("depmixS4")
library("data.table")

df <- read.table("Dataset1.txt", header = TRUE, sep = ",")
set.seed(1)

# get a vector of nrow(distinct observation)
get_ntimes <- function(data)
{
  ntimes <- c()
  idx <- 1
  for (day in unique(format(data$Date, "%j"))) {
    ntimes[idx] <- nrow(data[format(data$Date, "%j") == day,])
    idx <- idx + 1
  }
  return(ntimes)
}

# test optimal parameters for single feature (7*k combinations)
test_single_HMM <- function(data, k)
{
  t <- get_ntimes(data)
  bic_values <- c()
  idx <- 1
  for (i in 3:9) {
    for (j in 1:k) {
      # use try (or tryCatch) to skip errors / warnings generated by unsolvable parameters
      # more details: https://stackoverflow.com/questions/25363871/na-nan-inf-error-when-fitting-hmm-using-depmixs4-in-r
      try({
          mod <- depmix(response = data[, i] ~ 1, data = data, nstates = j, family = gaussian(), ntimes = t)
          fm <- fit(mod)
          bic_values[idx] <- BIC(fm)
      })
      # one trick in R: when declare empty vector v <- c() and assign v[1] <- 1, v[5] <- 5, print(v): 1 NA NA NA 5
      # so if bic_values is not assigned a value due to error, the next valid bic value will fill the gap with NA
      idx <- idx + 1
    }
  }
  return(bic_values)
}

# test optimal parameters for two features (21*k combinations)
test_pair_HMM <- function(data, k)
{
  pairs <- combn(3:9, 2)
  t <- get_ntimes(data)
  bic_values <- c()
  idx <- 1
  for (i in 1:ncol(pairs)) {
    for (j in 1:k) {
      try({
          mod <- depmix(response = list(data[, pairs[1, i]]~1, data[, pairs[2, i]]~1), data = data, nstates = j, family = list(gaussian(), gaussian()), ntimes = t)
          fm <- fit(mod)
          bic_values[idx] <- BIC(fm)
      })
      idx <- idx + 1
    }
  }
  return(bic_values)
}

# plot features
plot_features <- function(data)
{
  plot.new()
  par(mfrow = c(2,4))
  for (i in 3:9) {
    plot(format(data$Date, "%j"), data[, i], pch = 19, panel.first = grid(), xlab = "Time", ylab = names(data[i]))
  }
  x11()
  par(mfrow = c(2,4))
  for (i in 3:9) {
    plot(data[, i], panel.first = grid(), type = "l", ylab = names(data[i]))
  }
  x11()
}

# https://stackoverflow.com/questions/9500114/find-which-season-a-particular-date-belongs-to
# get season of dates
season <- function(dates) {
  WS <- as.Date("2012-12-15", format = "%Y-%m-%d") # Winter Solstice
  SE <- as.Date("2012-3-15",  format = "%Y-%m-%d") # Spring Equinox
  SS <- as.Date("2012-6-15",  format = "%Y-%m-%d") # Summer Solstice
  FE <- as.Date("2012-9-15",  format = "%Y-%m-%d") # Fall Equinox

  # Convert dates from any year to 2012 dates
  d <- as.Date(strftime(dates, format="2012-%m-%d"))

  ifelse (d >= WS | d < SE, "Winter", ifelse (d >= SE & d < SS, "Spring", ifelse (d >= SS & d < FE, "Summer", "Fall")))
}


# Task 1
df$Date <- as.POSIXct(df$Date, format = "%d/%m/%Y")
df$Time <- as.POSIXct(df$Time, format = "%T")
sundays <- df[weekdays(df$Date) == "Sunday",]
mornings <- sundays[sundays$Time >= strptime("08:00:00", "%T") & sundays$Time <= strptime("11:00:00", "%T"),]
# plot_features(mornings)
# single_bic <- test_single_HMM(mornings, 10)
# pair_bic <- test_pair_HMM(mornings, 10)

m_mod1 <- depmix(response = Global_active_power ~ 1, data = mornings, nstates = 9, family = gaussian(), ntimes = get_ntimes(mornings))
m_fm1 <- fit(m_mod1)
m_mod2 <- depmix(response = Global_active_power ~ 1, data = mornings, nstates = 10, family = gaussian(), ntimes = get_ntimes(mornings))
m_fm2 <- fit(m_mod2)
m_mod3 <- depmix(response = Global_active_power ~ 1, data = mornings, nstates = 11, family = gaussian(), ntimes = get_ntimes(mornings))
m_fm3 <- fit(m_mod3)

cat("\nSunday Mornings Model\n\n")
print(m_fm1)
print(m_fm2)
print(m_fm3)
cat("\n")


# # Task 2
nights <- sundays[sundays$Time >= strptime("21:00:00", "%T") & sundays$Time <= strptime("23:59:59", "%T"),]
# plot_features(nights)
# single_bic <- test_single_HMM(nights, 10)
# pair_bic <- test_pair_HMM(nights, 10)

n_mod1 <- depmix(response = Global_active_power ~ 1, data = nights, nstates = 8, family = gaussian(), ntimes = get_ntimes(nights))
n_fm1 <- fit(n_mod1)
n_mod2 <- depmix(response = Global_active_power ~ 1, data = nights, nstates = 9, family = gaussian(), ntimes = get_ntimes(nights))
n_fm2 <- fit(n_mod2)
n_mod3 <- depmix(response = Global_active_power ~ 1, data = nights, nstates = 10, family = gaussian(), ntimes = get_ntimes(nights))
n_fm3 <- fit(n_mod3)

cat("\nSunday Nights Model\n\n")
print(n_fm1)
print(n_fm2)
print(n_fm3)
cat("\n")


# Task 3 (a)
m_dt <- data.table(mornings)
n_dt <- data.table(nights)
m_avg <- m_dt[, mean(Global_active_power), by = Time]
n_avg <- n_dt[, mean(Global_active_power), by = Time]

plot.new()
plot(m_avg, pch = 19, panel.first = grid(), main = "Sunday Mornings", xlab = "Time", ylab = "Average Global Active Power")
x11()
plot(n_avg, pch = 19, panel.first = grid(), main = "Sunday Nights", xlab = "Time", ylab = "Average Global Active Power")


# Task 3 (b)
m_week <- m_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = format(Date, "%j")]
colnames(m_week)[1] <- "day of year"
m_month <- m_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = format(Date, "%b")]
colnames(m_month)[1] <- "month"
m_season <- m_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = season(Date)]

cat("Sunday Mornings\n\n")
print(m_week)
cat("\n")
print(m_month)
cat("\n")
print(m_season)
cat("\n")

n_week <- n_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = format(Date, "%j")]
colnames(n_week)[1] <- "day of year"
n_month <- n_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = format(Date, "%b")]
colnames(n_month)[1] <- "month"
n_season <- n_dt[, list(min = min(Global_active_power), max = max(Global_active_power), mean = mean(Global_active_power), sd = sd(Global_active_power)), by = season(Date)]

cat("Sunday Nights\n\n")
print(n_week)
cat("\n")
print(n_month)
cat("\n")
print(n_season)
cat("\n")